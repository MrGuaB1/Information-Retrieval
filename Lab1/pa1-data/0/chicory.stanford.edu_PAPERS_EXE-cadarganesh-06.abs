this paper presents exe an effective bug finding tool that automatically generates inputs that crash real code instead of running code on manually or randomly constructed input exe runs it on symbolic input initially allowed to be anything as checked code runs exe tracks the constraints on each symbolic ie input derived memory location if a statement uses a symbolic value exe does not run it but instead adds it as a constraint all other statements run as usual if code conditionally checks a symbolic expression exe forks execution constraining the expression to be true on the true branch and false on the other because exe reasons about all possible values on a path it has much more power than a traditional runtime tool 1 it can force execution down any feasible program path and 2 at dangerous operations eg a pointer dereference or assertion it detects if the current path constraints allow em any value that causes a bug when a path terminates or hits a bug exe automatically generates a test case by solving the current path constraints to find concrete values using its own co designed constraint solver stp because exe's constraints have no approximations feeding this concrete input to an uninstrumented version of the checked code will cause it to follow the same path and hit the same bug assuming deterministic code exe works well on real code finding bugs along with inputs the udhcpd dhcp server the pcre regular expression library and the bsd and linux packet filter implementations
