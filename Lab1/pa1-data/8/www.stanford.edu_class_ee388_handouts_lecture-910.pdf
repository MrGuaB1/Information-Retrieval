density evolution general message passing page 1 ee388 modern coding theory density evolution andrea montanari lecture 9 10 4 27 29 2009 we already studied density evolution for the binary erasure channel the objective of this week is to understand and implement density evolution for a general message passing algorithm general message passing recall that a general message passing algorithm is defined by message update rules of the form  t 1 i a  yi  t b i b i a 1  t a i   t j a j a i 2 density evolution for this algorithm is defined by the distributional recursion  t 1 d  y  t 1  t l 1 3  t d   t 1  t k 1 4 despite the formal similarity between these equations and eqs 1 2 one has to pay attention to the difference in the density evolution d denoted equality in distribution between random variables in these equalities  t  t 1  t 2 are understood to be iid random variables and the same for  t  t 1  t 2 further y is distributed according to the transition probability q y 1 l with the variable node degree distribution  and k with the check node degree distribution  a more explicit expression can be written by introducing the distributions of  t and  t to be denoted respectively as at a assuming for the sake of simplicity that the message alphabet is finite we can write the density evolution equations as at 1  l l y q y 1 1 l 1 at 1 at l 1 i   y 1 l 1 5 at  k k 1 k 1 at 1 at k 1 i   1 k 1 6 the asymptotic bit error rate can be computed in terms of the above distributions lim n pb t n l ll y q y 1 1 l at 1 at l i x y 1 l 1 7 consider a channel family bms  ordered by physical degradation with respect to the parameter  assum ing bp decoding it is easy to show that the asymptotic bit error rate is non increasing in t and non decreasing in  typically message passing decoding algorithms have a special message value that corresponds to max imum reliability let us denote it by then the threshold for a given message passing decoder and ldpc ensemble is defined as  sup 0 lim t lim n pb t n 0  0 sup 0 lim t at   0 8 for most reasonable message passing decoders ldpc ensembles and bms channels it is possible to show that  is strictly positive 1 page 2 implementation if the message alphabet is finite and its size m is small one can store at at as real vectors and compute them recursively using equations 5 6 if the message alphabet is very large or infinite there are several methods for approximating eqs 5 6 numerically one that is very easy to program is to replace the distributions a a by samples pt 1 2 n pt 1 2 n these should be thought of as ideally iid samples with distribution respectively at at at each time step one generates a new sample pt from pt and a new pt 1 from pt mimicking eqs 5 6 for instance to generate the sample pt one repeats n times the following operation draw an integer k with distribution k and k 1 indices i 1 i k 1 iid and uniformly random in n then compute a new element of pt from the corresponding elements of pt   i 1 i k 1 how do you expect the precision of this algorithm to behave with n how would you use it to estimate say the bit error rate for a large number of iterations there are in fact more efficient ways of implementing density evolution for bp we will discuss some ideas in class summary at the end of this week you should know 1 how to define density evolution for a general message passing algorithm for a general bms channel 2 the basic properties of density evolution monotonicity threshold etc 3 how to implement density evolution numerically the material treated this week can be found in sections 4.4 4.9 of mct page 218 onwards work write a program to implement density evolution for a quantized message passing decoder use it to determine the threshold of irregular ensembles for the decoder with erasure see last week's handout for definition over the bsc  more precisely consider the family of ensembles with design rate r 1 2 and degree distribution pair node perspective l x 1  x3 x4 9 r x 1  x6 x8 10 parametrized by  0 1 determine numerically the threshold value   as a function of  i expect to receive 1 a print out of the code 2 a plot of the curve   2
