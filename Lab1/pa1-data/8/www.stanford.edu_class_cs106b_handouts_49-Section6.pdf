section 6 trees page 1 eric roberts handout 49 cs106b february 27 2012 section 6 trees for problems 1 2 and 3 assume that bstnode is defined as follows struct bstnode string key bstnode left right 1 tracing binary tree insertion chapter 16 review question 9 page 711 in the first example of binary search trees the text uses the names of the dwarves from walt disney's 1937 classic animated film snow white and the seven dwarves dwarves of course occur in other stories in jrr tolkien's the hobbit for example 13 dwarves arrive at the house of bilbo baggins in the following order dwalin balin kili fili dori nori ori oin gloin bifur bofur bombur thorin diagram the binary search tree that results from inserting the names of these dwarves into an empty tree in the order in which they arrive once you have finished answer the following questions about your diagram 1a what is the height of the resulting tree 1b which nodes are leaves 1c which nodes if any are out of balance 1d which key comparisons are required to find the string gloin in the tree 2 calculating the height of a binary tree chapter 16 exercise 6 page 716 write a function int height bstnode tree that takes a binary search tree and returns its height 3 checking whether a tree is balanced chapter 17 exercise 7 page 716 write a function bool isbalanced bstnode tree that determines whether a given tree is balanced according to the definition in the section on balanced trees to solve this problem all you really need to do is translate the definition of a balanced tree more or less directly into code if you do so however the resulting implementation will be quite inefficient because it has to make several passes over the tree the real challenge in this problem is to implement the isbalanced function so that it determines the result without looking at any node more than once page 2 2 4 changing the interpreter into a compiler chapter 17 exercise 9 page 760 although the interpreter program that appears in this chapter is considerably easier to implement than a complete compiler it is possible to get a sense of how a compiler works by defining one for a simplified computer system called a stack machine a stack machine performs operations on an internal stack which is maintained by the hardware in much the same fashion as the calculator described in chapter 4 for the purposes of this problem you should assume that the stack machine executes the operations shown in figure 1 write a function void compile istream & infile ostream & outfile that reads expressions from infile and writes to outfile a sequence of instructions for the stack machine that have the same effect as evaluating each of the expressions in the input file and displaying their result for example if the file opened as infile contains x 7 y 5 2 x 3 y calling compile infile outfile should write the following code to outfile load 7 store x display load 5 store y display load 2 load x mul load 3 load y mul add display figure 1 stack machine instructions load n pushes the constant n on the stack load var pushes the value of the variable var on the stack store var stores the top stack value in var without actually popping it display pops the stack and displays the result add sub mul div these instructions pop the top two values from the stack and apply the indicated operation pushing the final result back on the stack the top value is the right operand the next one down is the left page 3 3 5 constant folding chapter 17 exercise 8 page 760 after it parses an expression a commercial compiler typically looks for ways to simplify that expression so that it can be computed more efficiently this process is called optimization one common technique used in the optimization process is constant folding which consists of identifying subexpressions that are composed entirely of constants and replacing them with their value for example if a compiler encountered the expression sec 24 60 60 days there would be no point in generating code to perform the first two multiplications when the program was executed the value of the subexpression 24 60 60 is constant and might as well be replaced by its value 86400 before the compiler actually starts to generate code write a function foldconstants exp that takes a pointer to an expression and returns a pointer to an entirely new expression in which any subexpressions composed entirely of constants are replaced by the computed value
