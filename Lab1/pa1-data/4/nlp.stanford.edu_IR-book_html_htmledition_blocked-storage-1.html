blocked storage next up previous contents index next postings file compression up dictionary compression previous dictionary as a string contents index blocked storage we can further compress the dictionary by grouping terms in the string into of size and keeping a term pointer only for the first term of each block figure 5.5 we store the length of the term in the string as an additional byte at the beginning of the term we thus eliminate term pointers but need an additional bytes for storing the length of each term for we save bytes for term pointers but need an additional bytes for term lengths so the total space requirements for the dictionary of reuters rcv1 are reduced by 5 bytes per four term block or a total of bringing us down to 10.37 1 mb figure 5.6 search of the uncompressed dictionary a and a dictionary compressed by blocking with b by increasing the block size we get better compression however there is a tradeoff between compression and the speed of term lookup for the eight term dictionary in figure 5.6 steps in binary search are shown as double lines and steps in list search as simple lines we search for terms in the uncompressed dictionary by binary search a in the compressed dictionary we first locate the term's block by binary search and then its position within the list by linear search through the block b searching the uncompressed dictionary in a takes on average steps assuming each term is equally likely to come up in a query for example finding the two terms aid and box takes three and two steps respectively with blocks of size in b we need steps on average more for example finding den takes one binary search step and two steps through the block by increasing we can get the size of the compressed dictionary arbitrarily close to the minimum of but term lookup becomes prohibitively slow for large values of one source of redundancy in the dictionary we have not exploited yet is the fact that consecutive entries in an alphabetically sorted list share common prefixes this observation leads to front coding figure 5.7 a common prefix is identified for a subsequence of the term list and then referred to with a special character in the case of reuters front coding saves another 2.41 2 mb as we found in an experiment other schemes with even greater compression rely on minimal perfect hashing that is a hash function that maps terms onto without collisions however we cannot adapt perfect hashes incrementally because each new term causes a collision and therefore requires the creation of a new perfect hash function therefore they cannot be used in a dynamic environment even with the best compression scheme it may not be feasible to store the entire dictionary in main memory for very large text collections and for hardware with limited memory if we have to partition the dictionary onto pages that are stored on disk then we can index the first term of each page using a b tree for processing most queries the search system has to go to disk anyway to fetch the postings one additional seek for retrieving the term's dictionary page from disk is a significant but tolerable increase in the time it takes to process a query table 5.2 dictionary compression for reuters rcv1 data structure size in mb dictionary fixed width 19.211 2 dictionary term pointers into string 10.8 7.6 with blocking 10.3 7.1 with blocking & front coding 7.9 5.9 table 5.2 summarizes the compression achieved by the four dictionary data structures exercises estimate the space usage of the reuters rcv1 dictionary with blocks of size and in blocked dictionary storage estimate the time needed for term lookup in the compressed dictionary of reuters rcv1 with block sizes of figure 5.6 b and what is the slowdown compared with figure 5.6 a next up previous contents index next postings file compression up dictionary compression previous dictionary as a string contents index 2008 cambridge university press this is an automatically generated page in case of formatting errors you may want to look at the pdf edition of the book 2009 04 07
