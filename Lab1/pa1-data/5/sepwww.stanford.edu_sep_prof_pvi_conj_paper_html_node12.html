nearest neighbor interpolation next up previous print clean next a family of nearest neighbor up normal moveout and other previous normal moveout and other nearest neighbor interpolation deformations begin from the task of selecting a value val from an array vec ix ix 1 nx the points of the array are at locations x x0 dx ix 1 given the location x of the desired value we backsolve for ix in fortran conversion of a real value to an integer is done by truncating the fractional part of the real value to get rounding up as well as down we add a half before conversion to an integer namely ix int 1.5 x x0 dx this gives the nearest neighbor the adjoint to extracting a value from a vector is putting it back a convenient subroutine for nearest neighbor interpolation is spot0 nearest neighbor interpolation essentially val vec 1.5 t t0 dt subroutine spot0 adj add nt t0 dt t val vec integer it adj add nt real t0 dt t val vec nt call adjnull adj add val 1 vec nt it 1.5 t t0 dt if 0 it && it nt if adj 0 add value onto vector vec it vec it val else take value from vector val val vec it return end recall subroutine advance for jump 0 its matrix equivalent is an identity matrix for other values of jump the identity matrix has its diagonal shifted up or down now examine subroutine spot0 and think about its matrix equivalent since its input is a single value and its output is a vector that means its matrix is a column vector so the adjoint operator is a row vector the vector is all zeros except for somewhere where there is a 1 next up previous print clean next a family of nearest neighbor up normal moveout and other previous normal moveout and other stanford exploration project 10 21 1998
