section handout page 1 cs107 handout 10 spring 2008 april 14 2008 section handout problem 1 meet the flintstones consider the following c style struct definitions typedef struct rubble need tag name for self reference int betty char barney 4 struct rubble bammbamm rubble typedef struct short wilma 2 short fred 2 rubble dino flintstone accurately diagram what computer memory looks like after the following seven lines of code have executed rubble simpsons flintstone jetsons 4 simpsons &jetsons 0 dino jetsons 1 wilma 3 short &simpsons strcpy simpsons 2 barney bugs bunny flintstone jetsons fred dino bammbamm simpsons char jetson 4 fred simpsons barney 4 page 2 2 problem 2 scheme scheme is a language whose primary built in data structure is the linked list unlike any of the lists you ve dealt with in c scheme lists are fully heterogeneous that is the entries needn t all be the same type some example lists are i 2 3 5 7 ii house at pooh corner iii yankees 2 diamondbacks 1 iv 4 calling birds 3 french hens 2 turtle doves 1 partridge these linked lists are so flexible individual elements might themselves be lists if that's the case then lists can be nested to any depth v 1 2 buckle my shoe vi one 2 three 4 5 six vii how nested can u go how nested can u go we can provide heterogeneous lists in c but they don t come easy in order for them to work the individual elements of the list must carry their own type information the idea is to tag each list node with some enumerated type that tells us what the rest of the node contains we ll just pretend that integers and strings are the only atomic types of interest the third list above if bound to the stack variable gamethree would be structured as follows list list list list nil str yankees 0 str diamondbacks 0 int int 2 1 gamethree page 3 3 list list list nil str one 0 nestednumbers list str six 0 int 5 list list int 2 nil list list nil str three 0 int 4 the one 2 three 4 5 six list if bound to the stack variable nestednumbers would look like each node of a list clearly advertises what it stores because every node stores an identifier of type nodetype see below in the first few bytes what that identifier is dictates how big the node needs to be and what resides there we ll officially allow only strings and integers therefore the following enumerated type suits our needs typedef enum integer string list nil nodetype when handed a list we need to pull the nodetype value from the first sizeof nodetype bytes from that we know whether the rest of the node note the characters of a string node are inside the node int 2 str yankees 0 list nil stores an int as with stores a null terminated character array as with stores two addresses as with stores nothing the end of some list has been reached or page 4 4 the concatall function takes a well formed list and returns the ordered concatenation of all of the list's strings including those in nested sublists integers should just be skipped and shouldn t contribute to the return value at all your implementation shouldn t orphan any memory traverses a properly structured list and returns the ordered concatenation of all strings including those in nested sublists when applied to the two lists drawn above the following strings would be returned concatall gamethree would return yankeesdiamondbacks concatall nestednumbers would return onethreesix typedef enum integer string list nil nodetype char concatall nodetype list
