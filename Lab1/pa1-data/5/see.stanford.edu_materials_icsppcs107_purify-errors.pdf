purify at a glance page 1 cs107 handout 13 autumn 2000 october 5 2000 purify at a glance here's a quick overview of the most common purify error messages if you want to know more about these errors or about other errors not listed here you can run man purify from any of the sweet hall machines abr array bounds read abw array bounds write this error indicates that you ve gone past the end of an array whether allocated directly on the stack eg char words max_words or on the heap with malloc for example trying to do the following will result in an abr int arr i j arr malloc sizeof int 10 for i 0 i 10 i++ arr i i j arr 11 abr as you might expect an abw occurs when you try to write past the end of an array continued from above arr 11 23 note however that you don t actually have to have an array per se to get this error if you go past the end of any block of memory you ll have this problem think of non arrays as arrays of size one for example assume that short ints are 2 bytes and longs are 4 bytes long num num malloc sizeof short int num 65537 this code only allocates two bytes but then tries to use four so purify will report an abw here with something like abw array bounds write this is occurring while in main ccztdiy_1 o _start crt1 o writing 4 bytes to 0x93750 in the heap 2 bytes at 0x93752 illegal address 0x93750 is at the beginning of a malloc d block of 2 bytes this block was allocated from malloc rtlib o main ccztdiy_1 o _start crt1 o page 2 2 abr and abw will probably be the most common purify error you ll see in this class with mlk a close third mlk memory leak one of the most useful features of purify is its ability to track your dynamically allocated memory and let you know when your program leaks it unfortunately purify has no way of knowing where you meant to free the memory or should free the memory so the best it can do is show you where you allocated it to continue from the short example with the abw if the memory is not freed before the program ends purify will report the following mlk 2 bytes leaked at 0x93750 this memory was allocated from malloc rtlib o main ccztdiy_1 o _start crt1 o purify heap analysis combining suppressed and unsuppressed blocks blocks bytes leaked 1 2 potentially leaked 0 0 in use 0 0 total allocated 1 2 in addition to specifying each leak purify also gives an overall analysis at the end of the program if you forget to fclose a file that you ve opened you ll probably get 4100 bytes per instance on the potentially leaked line in use refers to memory allocated in the global data segment for things like randomizing don t worry about what that means if you don t know you do not need to worry about anything but leaked memory on the first line however if you can get rid of potentially leaked memory by closing open files please do so fmr free memory read you re using memory after you ve freed it the most common cause of this is when two parts of the code share a pointer to the same string and then one part frees it while the other part of the code expects the string to remain in place for example page 3 3 void foo const char string char s char malloc strlen string 1 strcpy s string bar s printf s n s fmr free s fum void bar char x free x watch out for fmrs when you have data structures being passed around your program it's very easy to free it too soon fum freeing unallocated memory this error is directly related to fmr it simply means that you are freeing memory that has already been freed so in the example for fmr the line free s in foo will give this error fnh freeing non heap memory hopefully everyone remembers from 106 that you should always free memory you dynamically allocate and that you should never try to free memory you didn t allocate stack memory should never be freed char buf 1000 strcpy buf hello world free buf fnh in this case buf is not on the heap and will be deallocated when the containing function ends npw null pointer write npr null pointer read null can never be a valid memory address if you try to read it or write it you ll get this error null pointer reads writes are common causes of segmentation faults page 4 4 umr uninitialized memory read this error comes up if you try to read a variable's value without setting it for example not giving counter variables an initial value of 0 is a common cause int count ch while ch fgetc fp eof count++ the first time count is incremented in this loop it has no initial value it's not guaranteed to be zero although often it will be so the code may or may not run correctly the fix is simple of course set count 0 before the loop cor fatal core dump when your program has a segmentation fault or bus error the purify log will also contain this message it shows the exact line that caused the crash
