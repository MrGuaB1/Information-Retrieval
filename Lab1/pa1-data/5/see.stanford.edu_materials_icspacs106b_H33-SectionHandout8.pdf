section handout 8 page 1 cs106b handout 33 winter 07 08 march 3 2008 section handout 8 problem 1 extending editor buffer write the method movetowordbegin for each of the following versions of the buffer object a array implementation b stack implementation c singly linked list implementation this function should move the cursor to the beginning of the word the cursor is currently positioned in if the cursor were between the e and d in jumped t hequickbrownfoxjumped overthelazy calling movecursortowordbegin would position the cursor before the j t hequickbrownfoxjumped overthelazy be careful to handle gracefully the cases where the cursor is already at the beginning of a word by moving cursor to beginning of the previous word or at the beginning of the buffer what is the running time of this operation in big o notation for the three implementations you may use the function isspace which takes a character and returns a boolean which is true if the character is a space false otherwise problems 2 5 for the following tree problems assume that the following type definition provides the underlying structure for the tree struct nodet string key nodet left nodet right page 2 2 problem 2 tree trivia given the following binary search tree benton carter greene hathaway ross weaver morganstern a what is the height of this tree which nodes in this tree are the leaves who are the siblings of the node morganstern b what is the sequence of nodes visited on a pre order tree traversal in order post order c if we entered the node del amico where would it end up in this tree d what was the first node inserted into this tree assuming that the tree hasn t been rebalanced e say we ran the following code on the above tree where root points to the root node of the tree ie greene queue nodet queue queue enqueue root while queue isempty nodet tree queue dequeue cout tree key endl queue enqueue tree left queue enqueue tree right what is the sequence of nodes visited by this code in what order have we essentially visited the tree problem 3 tree equal write a function which takes two binary trees of type nodet as defined above and returns a boolean value which indicates whether the two trees are equal ie have the same structure and values problem 4 trimleaves a write a function trimleaves nodet & tree which will take a binary tree and remove all of its leaves thus given the following tree page 3 3 the function will produce the following tree b note that the prototype of trimleaves as given passes tree by reference what would happen if it was instead passed by value problem 5 balanced trees as we saw in class the definition of a binary search tree does not in fact guarantee that the root node falls in the middle of the complete list of keys for example both of the following trees are binary search trees containing the names of the seven dwarves page 4 4 bashful doc dopey grumpy happy sleepy sneezy bashful doc dopey grumpy happy sleepy sneezy only the tree on the left guarantees o log n search performance the tree on the right is extremely unbalanced it's essentially a linked list and requires o n time to search a binary tree is balanced if each of the two following conditions is met 1 the height of its left and right subtree differ by no more than one where the height of a tree is defined to be the length of the longest path from the root to a leaf thus the height of the tree appearing at the left of the example on the previous page is 3 while the height of the example at the right is 7 2 both of its left and right subtrees are themselves balanced both conditions are important for example the tree shown below bashful doc dopey grumpy happy sleepy sneezy is a legal binary search tree that meets the first condition for being balanced but not the second write recursive implementations of the two functions int treeheight nodet t bool isbalanced nodet t that return the height of a tree and whether it is balanced respectively
