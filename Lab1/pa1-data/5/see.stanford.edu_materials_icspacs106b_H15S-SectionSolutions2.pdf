h15s section solutions 2 page 1 cs106b handout 15s winter 07 08 january 23 2008 section solutions 2 problem 1 vectors a vector emailmsg mailvector b void removespam vector emailmsg & v for int i v size 1 i 0 i emailmsg mail v i if mail subject find spam 0 v removeat i note that you could work forwards instead of backwards ie loop from 0 to size 1 instead of the other way around however if you did you d have to make sure to decrement i whenever you removed a message since otherwise you d skip an index c we use another vector of course struct emailmsg vector string to string from string message string subject int date int time access to the last element of emailmsg email would be done by string lastaddress email to email to size 1 problem 2 queues the client version of reverse queue in order to change the order of elements in the queue we use an external stack void reversequeue queue int & queue stack int stack while queue isempty stack push queue dequeue while stack isempty page 2 queue enqueue stack pop problem 3 using the scanner and stack classes include stack h include scanner h bool processopentag scanner& scanner stack string & tagstack string tag scanner nexttoken tagstack push tag return true bool processclosetag scanner& scanner stack string & tagstack string tag scanner nexttoken if tagstack isempty && tag tagstack pop return true else return false bool processtag scanner& scanner stack string & tagstack read the next token to see if we found an opening or closing tag string token scanner nexttoken if token return processclosetag scanner tagstack else scanner savetoken token so processopentag can use it return processopentag scanner tagstack bool iscorrectlynested string htmlstr scanner scanner scanner setspaceoption scanner ignorespaces stack string tagstack scanner setinput htmlstr start by assuming it is balanced bool isbalanced true page 3 while scanner hasmoretokens string token scanner nexttoken if token if processtag scanner tagstack isbalanced false break get rid of part of tag scanner nexttoken if tagstack isempty isbalanced false return isbalanced problem 4 map warm up char mostfrequentcharacter ifstream &in int &numoccurrences map int charfrequencies numoccurrences 0 int nextchar while nextchar in get eof convert it to a string for lookup in the symbol table string foundchar foundchar char nextchar if we find it incremement the stored value otherwise enter in a new one int frequency 1 if charfrequencies containskey foundchar frequency charfrequencies foundchar 1 charfrequencies foundchar frequency now use an iterator to find the most occurring character map int iterator it charfrequencies iterator string maxcharacter while it hasnext string character it next int frequency charfrequencies character if frequency numoccurrences page 4 maxcharacter character numoccurrences frequency return maxcharacter 0 problem 5 minesweeper bool locationongrid int row int col grid int & bombcounts return row 0 && col 0 && row bombcounts numrows && col bombcounts numcols void markbomb int row int col grid int & bombcounts for int bombrow 1 bombrow 1 bombrow++ for int bombcol 1 bombcol 1 bombcol++ if locationongrid bombrow row bombcol col bombcounts bombcounts bombrow row bombcol col grid int makegridofcounts grid bool & bomblocations grid int bombcounts bomblocations numrows bomblocations numcols for int row 0 row bomblocations numrows row++ for int col 0 col bomblocations numcols col++ bombcounts row col 0 for int row 0 row bomblocations numrows row++ for int col 0 col bomblocations numcols col++ if bomblocations row col markbomb row col bombcounts return bombcounts page 5 note that markbomb uses two for loops to iterate through the 9 squares it needs to update rather than having a separate case for each square if it had a separate case for each this would not only be more messy and less elegant but it would be more error prone this is because while writing out 9 different cases you are much more likely to make an error on one of the lines than if you are only writing out two for loops
