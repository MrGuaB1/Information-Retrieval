admin thinking recursively procedural vs functional a familiar fractal page 1 admin assign 2 due today assign 3 out joy poll today's topics procedural recursion reading reader ch 5 6 today next lecture 9 thinking recursively recursive decomposition is the hard part find recursive sub structure solve problem using result from smaller subproblem s identify base case simplest possible case directly solvable recursion advances to it common patterns handle first and or last recur on remaining divide in half recur on one both halves make a choice among options recur on updated state placement of recursive call s recur then process versus process then recur procedural vs functional functional recursion function returns result computers using result from recursive call s procedural recursion no return value function returns void task accomplished during recursive calls example drawing fractal self similar structure repeats itself within outer fractal makes recursive call to draw inner fractal s a familiar fractal void drawfractal double x double y double w double h drawtriangle x y w h if w 2 h 2 return double halfh h 2 double halfw w 2 drawfractal x y halfw halfh left drawfractal x halfw 2 y halfh halfw halfh top drawfractal x halfw y halfw halfh right page 2 recursive art piet mondrian dutch painter 1872 1944 cubism neoplasticism i believe it is possible that through horizontal and vertical lines constructed with awareness but not with calculation led by high intuition and brought to harmony and rhythm these basic forms of beauty supplemented if necessary by other direct lines or curves can become a work of art as strong as it is true random pseudo mondrian choose one of three options divide canvas horizontally divide canvas vertically do nothing dividing produces two smaller canvases that can also be recursively painted in mondrian style base case stops at too small canvas mondrian code void drawmondrian double x double y double w double h if w 1 h 1 return base case fillrectangle x y w h randomcolor fill background switch randominteger 0 2 case 0 do nothing break case 1 bisect vertically double midx randomreal 0 w drawblackline x midx y h drawmondrian x y midx h drawmondrian x midx y w midx h break case 2 bisect horizontally double midy randomreal 0 h drawblackline x y midy w drawmondrian x y w midy drawmondrian x y midy w h midy break towers set of graduated disks stacked on a spindle goal is move tower from source to destination rules all disks on a spindle when not actively being moved have one spare spindle can move only one disk at a time can only place disk on top of larger disk a b c page 3 tower recursion move tower of height n from a to b using c starting thought divide the tower what is smaller instance of similar problem that helps divide n height tower into one disk and tower of height n 1 which one to separate top or bottom disk what do you do with other tower tower code void movetower int n char src char dst char tmp if n 0 movetower n 1 src tmp dst movesingledisk src dst movetower n 1 tmp dst src permutations want to enumerate all rearrangements abcd permutes to dcba cabd etc solving recursively choose a letter from input to append to output recursively permute remaining letters onto output what other options do you need to explore how to ensure each letter is used exactly once what is the base case permute strategy result is empty starting input is abcd choose a letter to be first say a result so far is a remaining input is bcd recursively permute to get all bcd combos after finishing permutations with a in front need to go again with b in front and then c and so on page 4 permute code void recpermute string sofar string rest if rest cout sofar endl else for int i 0 i rest length i++ string next sofar rest i string remaining rest substr 0 i rest substr i 1 recpermute next remaining wrapper function void listpermutations string s recpermute s tree of recursive calls p ac bd permute abcd p b acd p c abd p d abc p abc d p abcd p a bcd p ab cd p abd c p abdc p ad bc p acb d p acbd p acd b p acdb
