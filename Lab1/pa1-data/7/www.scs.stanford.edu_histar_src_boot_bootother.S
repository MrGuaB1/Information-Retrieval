include machine mmu h start an application processor this must be placed on a 4kb boundary somewhere in the 1st mb of conventional memory apbootstrap however due to some shortcuts below it's restricted further to within the 1st 64kb the ap starts in real mode with cs selector set to the startup memory address 16 cs base set to startup memory address cs limit set to 64kb cpl and ip set to 0 set prot_mode_cseg 0x8 kernel code segment selector set prot_mode_dseg 0x10 kernel data segment selector set cr0_pe_on 0x1 protected mode enable flag globl start start code16 assemble for 16 bit mode cli disable interrupts cld string operations increment set up the important data segment registers ds es ss xorw ax ax segment number zero movw ax ds data segment movw ax es extra segment movw ax ss stack segment print a diagnostic message movw $0 xb800 ax movw ax es movw 0x0600 es 0x00 switch from real to protected mode using a bootstrap gdt and segment translation that makes virtual addresses identical to their physical addresses so that the effective memory map does not change during the switch lgdt gdtdesc movl cr0 eax orl cr0_pe_on eax movl eax cr0 jump to next instruction but in 32 bit code segment switches processor into 32 bit mode ljmp prot_mode_cseg protcseg code32 protcseg movw prot_mode_dseg ax our data segment selector movw ax ds ds data segment movw ax es es extra segment movw ax fs fs movw ax gs gs movw ax ss ss stack segment movw 0x0700 a 0xb8002 movl start 4092 ecx movl start eax jmp ecx align 4 gdt quad 0 null segment seg32_asm sta_x sta_r 0x0 0xffffffff code seg seg32_asm sta_w 0x0 0xffffffff data seg align 16 gdtdesc word 0x17 sizeof gdt 1 gdtaddr long gdt address gdt
