tcp server example page 1 tcp server example void doaccept int lfd sockaddr_in sin bzero &sin sizeof sin socklen_t sinlen sizeof sin int nfd accept lfd sockaddr &sin &sinlen if nfd 0 int main int argc char argv int lfd inetsocket sock_stream your_port inaddr_any if lfd 0 fatal socket strerror errno n if listen lfd 5 0 fatal listen m n fdcb lfd selread wrap doaccept lfd amain page 2 simple list insert struct element int data struct element next void insert element list int data element e new element e data data e next list list e page 3 first attempt at synchronization int insert_lock void insert element list int data while insert_lock acquire lock insert_lock 1 element e new element e data data e next list list e insert_lock 0 release lock page 4 need atomic read write operation example int test and set int lockp sets lockp 1 and returns old value now can implement spinlocks define lock lockp while test_and_set lockp define unlock lockp lockp 0 page 5 synchronization on i386 xchg instruction exchanges reg with mem _test_and_set movl 8 esp edx movl $1 eax xchg eax edx ret cpu locks memory system around read and write prevents other uses of the bus eg dma operates at memory bus speed not cpu speed must slower than cached read buffered write page 6 synchronization on alpha ldl l load locked stl c store conditional _test_and_set ldq_l v0 0 a0 bne v0 1f addq zero 1 v0 stq_c v0 0 a0 beq v0 _test_and_set mb addq zero zero v0 1 ret zero ra 1 page 7 new insert int insert_lock void insert element list int data lock &insert_lock acquire lock element e new element e data data e next list list e unlock &insert_lock release lock are spinlocks enough page 8 need blocking mutexes condition variables can t do producer consumer with just spinlocks need to relinquish cpu until locks ready must have cooperation of scheduler
