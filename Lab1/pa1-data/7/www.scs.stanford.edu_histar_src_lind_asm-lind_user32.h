ifndef user32_h define user32_h 1 ia32 compatible user structures for ptrace these should be used for 32bit coredumps too struct user_i387_ia32_struct u32 cwd u32 swd u32 twd u32 fip u32 fcs u32 foo u32 fos u32 st_space 20 8 10 bytes for each fp reg 80 bytes fsave frame with extensions struct user32_fxsr_struct unsigned short cwd unsigned short swd unsigned short twd not compatible to 64bit twd unsigned short fop int fip int fcs int foo int fos int mxcsr int reserved int st_space 32 8 16 bytes for each fp reg 128 bytes int xmm_space 32 8 16 bytes for each xmm reg 128 bytes int padding 56 struct user_regs_struct32 __u32 ebx ecx edx esi edi ebp eax unsigned short ds __ds es __es unsigned short fs __fs gs __gs __u32 orig_eax eip unsigned short cs __cs __u32 eflags esp unsigned short ss __ss struct user32 struct user_regs_struct32 regs where the registers are actually stored int u_fpvalid true if math co processor being used for this mess not yet used struct user_i387_ia32_struct i387 math co processor registers the rest of this junk is to help gdb figure out what goes where __u32 u_tsize text segment size pages __u32 u_dsize data segment size pages __u32 u_ssize stack segment size pages __u32 start_code starting virtual address of text __u32 start_stack starting virtual address of stack area this is actually the bottom of the stack the top of the stack is always found in the esp register __u32 signal signal that caused the core dump int reserved no __u32er used __u32 u_ar0 used by gdb to help find the values for the registers __u32 u_fpstate math co processor pointer __u32 magic to uniquely identify a core file char u_comm 32 user command that was responsible int u_debugreg 8 endif
