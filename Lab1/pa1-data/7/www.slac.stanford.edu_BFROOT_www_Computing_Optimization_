babar application optimization slac pep ii babar slac ral babar logo hepic e s & h databases pdg hep preprints organization detector computing physics documentation personnel glossary sitemap search hypernews unwrap page comp search who's who meetings faq homepage archive environment administration new user info web info tools monitoring training tools & utils programming c++ standard srt afs cvs qa and qc remedy histogramming operations promptreco simulation production online sw dataflow detector control evt processing run control calibration databases offline workbook coding standards simulation reconstruction prompt reco babar grid data distribution beta & betatools kanga & root analysis tools roofit toolkit data management data quality event display event browser code releases databases check this page for html 4.01 transitional compliance with the w3c validator more checks babar application optimization the application optimization group offers code profiling and expert advice to help babar users find inefficiencies and potential speedups in their code if you have an analysis that you would like to have profiled please get in touch with one of the optimization group members listed below contacts examples of code optimization how to profile your code tips to increase the speed of your code optimization meetings and talks optimization group members dave brown dave_brown lbl gov gregory dubois felsmann gpdf hep caltech edu bertrand echenard echenard hep caltech edu kyle fransham fransham uvic ca homer neal homer slac stanford edu there is also an application optimization hypernews group appopt hn slac stanford edu how to profile your code here are detailed instructions on how to generate and interpret a profile examples of code optimization here is a step by step example of the profiling and optimization of a real user analysis tips to increase the speed of your code here is a list of some tips and suggestions for performance increases that the optimization group suggests when doing a fit load the data tree into memory on initialization rather than reading it from disk for each minuit iteration avoid using maps of the type std map tstring type as they are very inefficient reduce the number of std string that are created tstring should be limited to the strict minimum as they are slow and tend to fragment the memory if created and destroyed again and again they are also very slow when possible passing function parameters by reference instead of by value can reduce the number of times an object is copied in one particular optimization a function getparvalue tstring parname was calling findparameter tstring parname changing these functions to getparvalue tstring &parname and findparameter tstring &parname note the & saved two unnecessary constructions of tstring on every function call in general avoid anything of the type loop loop function tstring string initialize complex objects outside of loops for example for int i 0 i 10 i myobject anobj i true 42 do some operations can be changed to myobject anobj 0 true 42 for int i 0 i 10 i anobj setparm i do some operations thus saving ten initializaions of an object if you only ever add or remove items from the end of a list use a std vector if it's absolutely necessary to add or remove elements to the middle of the list use an std list but only then if your list size is large 10 as a ballpark if you have to search for elements in a vector or a list consider sorting the elements as they re inserted sorting a vector after all the elements have been added can sometimes be useful too hashtables are much more efficient at searching than linear searches on vectors the standard template library does not implement a hash table but boost does it's also not hard to write hashify functions for vectors and lists the optimization group can help with this compiling with ccflags o2 increases the speed virtual functions are resolved at runtime not at compile time like non virtual functions and thus have larger overhead if you have a simple get function that returns the value of a private variable in a class the overhead associated with the lookup can be larger than the cost of the function if this function is rarely called this is okay but when you start having to call this function inside multiply nested loops it can get expensive adding an inline non virtual funtion to the class that returns this specific variable can improve speed significantly old meetings and talks old optimization group meetings application optimization at collaboration meeting october 2008 page author s kyle fransham fransham uvic ca last significant update may 25 2009
