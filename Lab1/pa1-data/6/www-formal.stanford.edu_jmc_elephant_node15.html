algol 50 next up previous next elephant programs as sentences up algol 48 and algol previous algol 48 algol 50 however by reifying variables algol 50 permits writing programs in a way that permits regarding programs in this fragment of algol 60 as just sugared versions of algol 50 programs instead of writing var t for some variable var we write where is a state vector giving the values of all the variables in the above program we ll have and the variables of the algol 60 program correspond to functions of time in the above first algol 50 version and become distinct constant symbols in the version of algol 50 with reified variables their distinctness is made explicit by the unique names axiom in expressing the program we use the assignment and contents functions and of mccarthy 1963 and mccarthy and painter 1967 is the new state that results when the variable var is assigned the value value in state is the value of var in state as described in those papers the functions a and c satisfy the axioms and the following function definitions shorten the expression of programs note that they are just function definitions and not special constructs we make the further abbreviation loop start 2 specially for this program and with this notation our program becomes in algol 50 the consequents of the clauses of the conditional expression are in 1 1 correspondence with the statements of the corresponding algol 60 program therefore the algol 60 program can be regarded as an abbreviation of the corresponding algol 50 program the operational semantics of the algol 60 program is then given by the sentence expressing the corresponding algol 50 program together with the axioms describing the data domain which in this case would be the peano axioms for natural numbers the transformation to go from algol 60 to algol 50 would be entirely local ie statement by statement were it not for the need to use statement numbers explicitly in algol 50 program fragments can be combined into larger fragments by taking the conjunction of the sentences representing them identifying labels where this is wanted to achieve a go to from one fragment to another and adding sentences to make sure that the program counter ranges don t overlap the correctness of the algol 50 program for multiplication by addition is expressed by note that we quantify over all initial state vectors the last part of the correctness formula states that the program fragment doesn t alter the state vector other than by altering p i and pc we have not carried the algol 50 idea far enough to verify that all of algol 60 is conveniently representable in the same style but no fundamental difficulties are apparent in treating recursive procedures a stack can be introduced but it would be more elegant to do without it by explicitly saying that the return is to the statement after the corresponding procedure call and variables are restored to their values at the time of the call this requires the ability to parse the past needed also for elephant 2000 we advocate an extended algol 50 for expressing the operational semantics of algol like programming languages ie for describing the sequence of events that occurs when the program is executed however our present application is just to illustrate in a simpler setting some features that elephant will require in particular proper treatment of calling a function procedure with side effects will require a state that can have a value during the evaluation of an expression nissim francez and amir pnueli see references used an explicit time for similar purposes unfortunately they abandoned it for temporal logic while some kinds of temporal logic are decidable temporal logic is too weak to express many important properties of programs next up previous next elephant programs as sentences up algol 48 and algol previous algol 48 john mccarthy fri nov 6 21 37 30 pst 1998
