cache performance on scientific code next memory hierarchy optimizations up introduction previous introduction cache performance on scientific code to illustrate the need for improving the cache performance of microprocessor based systems we present results below for a set of scientific programs for the sake of concreteness we pattern our memory subsystem after the mips r4000 the architecture consists of a single issue processor running at a 100 mhz internal clock the processor has an on chip primary data cache of 8 kbytes and a secondary cache of 256 kbytes both caches are direct mapped and use 32 byte lines the penalty of a primary cache miss that hits in the secondary cache is 12 cycles and the total penalty of a miss that goes all the way to memory is 75 cycles to limit the complexity of the simulation we assume that all instructions execute in a single cycle and that all instructions hit in the primary instruction cache we present results for a collection of scientific programs drawn from several benchmark suites this collection includes nasa7 and tomcatv from the spec benchmarks 27 ocean a uniprocessor version of a splash benchmark 25 and cg conjugate gradient ep embarassingly parallel is integer sort mg multigrid from the nas parallel benchmarks 3 since the nasa7 benchmark really consists of 7 independent kernels we study each kernel separately mxm cfft2d cholsky btrix gmtry emit and vpenta the performance of the benchmarks was simulated by instrumenting the mips object code using pixie 26 and piping the resulting trace into our cache simulator figure 1 breaks down the total program execution time into instruction execution and stalls due to memory accesses we observe that many of the programs spend a significant amount of time on memory accesses in fact 8 out of the 13 programs spend more than half of their time stalled for memory accesses next memory hierarchy optimizations up introduction previous introduction robert french
