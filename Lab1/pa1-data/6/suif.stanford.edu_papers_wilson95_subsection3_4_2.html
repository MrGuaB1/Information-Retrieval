sparse representation next evaluating dereferences up analyzing a procedure previous strong updates sparse representation because our analysis is interprocedural and needs to keep the entire input program in memory at once we have gone to considerable effort to use storage space efficiently since we analyze heap data as well as global and stack variables many possible memory locations could be included in the points to functions fortunately the information stored in the points to functions is very sparse pointers typically have only a few possible values so we record the possibilities using linked lists rather than bit vectors since the points to functions usually do not change very much between two adjacent program points we also incorporate the sparse representation described by chase et al 1 this scheme only records the points to values that change at each node because of the sparse points to function representation looking up the values of a pointer requires searching back for the most recent assignment to that location beginning at the current node we search back through the dominating flow graph nodes if we reach the procedure entry when searching for an assignment to a formal or extended parameter we compute the value of the initial points to function for that parameter if it has not already been recorded as described in section 3.2 this may add new extended parameters in the ptfs on the call stack since we only search for assignments in the dominating nodes each meet node must contain ssa functions 3 to identify the values to be assigned in it we insert these functions dynamically as new locations are assigned 1 the pseudo code for handling a meet node is shown in figure 9 for each function we look up the points to values at each predecessor node and combine the results to get the new points to values next evaluating dereferences up analyzing a procedure previous strong updates bob wilson
